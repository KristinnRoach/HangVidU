<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Component Experiments</title>
    <link rel="stylesheet" href="/src/styles/reset/reset-normalize.css" />
    <style>
      body {
        font-family: system-ui, -apple-system, sans-serif;
        background: #1a1a1a;
        color: #fff;
        margin: 0;
        padding: 20px;
      }

      #app {
        max-width: 800px;
        margin: 0 auto;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>

    <hr style="margin: 40px 0" />
    <h2 style="text-align: center">Web Components Test</h2>

    <!-- Test Web Components -->
    <v-counter count="5" label="Web Component"></v-counter>
    <v-form title="Web Component Form"></v-form>

    <script type="module">
      import { createCounter } from './src/utils/dom/wip-van-components/counter.js';
      import { createForm } from './src/utils/dom/wip-van-components/form.js';
      import './src/utils/dom/wip-van-components/web-components.js';

      const app = document.getElementById('app');
      createCounter(app);
      createForm(app);

      // Test programmatic interaction with Web Component
      setTimeout(() => {
        const wcCounter = document.querySelector('v-counter');
        console.log('Web Component count:', wcCounter.count);

        // Test prop reflection
        wcCounter.count = 100;
        console.log('Updated count to 100, attribute should reflect');
      }, 1000);
    </script>

    <!-- Minimal demo: show warning when skipping proxying of non-configurable property -->
    <script type="module">
      import defineComponent from './src/utils/dom/wip-interop/native-web/vanElla.js';

      // Demo runs immediately and logs to the console. Open the browser
      // console to observe the warning produced when proxying is skipped.
      (function demoSkipProxy() {
        const tag = 'x-nonconf-demo';
        const el = document.createElement(tag);

        // Create a non-configurable own property before definition/upgrade
        Object.defineProperty(el, 'foo', {
          value: 'secret-demo',
          configurable: false,
          writable: true,
          enumerable: true,
        });

        document.body.appendChild(el);

        // Define component - safe variant will detect the non-configurable
        // property and skip proxying while preserving the value. A small
        // console.warn will be emitted; the content will still render.
        defineComponent(tag, {
          initialProps: { foo: '' },
          template: `<div>\${foo}</div>`,
        });

        console.info(
          'x-nonconf-demo appended; check console for warning and the element content'
        );
      })();
    </script>

    <!-- Comparison demo: proxied vs non-configurable property behavior -->
    <script type="module">
      import defineComponent from './src/utils/dom/wip-interop/native-web/vanElla.js';

      (function demoCompare() {
        const tagP = 'x-proxied-demo';
        const tagS = 'x-skipped-demo';

        // Build UI
        const section = document.createElement('section');
        section.style.padding = '12px';
        section.style.borderTop = '1px solid #444';
        section.innerHTML = `
          <h3 style="margin:8px 0">Demo: proxied vs non-configurable property</h3>
          <div style="display:flex;gap:24px">
            <div id="proxied" style="flex:1">
              <strong>Proxied (configurable)</strong>
              <div id="proxied-host"></div>
              <button id="p-host-update">Set host property → HOST-UPDATED</button>
              <button id="p-attr-update">Set attribute → ATTR-UPDATED</button>
              <div>Rendered: <span id="p-render"></span></div>
            </div>
            <div id="skipped" style="flex:1">
              <strong>Skipped (non-configurable)</strong>
              <div id="skipped-host"></div>
              <button id="s-host-update">Set host property → HOST-UPDATED</button>
              <button id="s-attr-update">Set attribute → ATTR-UPDATED</button>
              <div>Rendered: <span id="s-render"></span></div>
            </div>
          </div>
        `;

        document.body.appendChild(section);

        // Create elements BEFORE definition to simulate pre-upgrade assignment
        const p = document.createElement(tagP);
        p.foo = 'proxied-initial'; // normal assignment (configurable)
        document.getElementById('proxied-host').appendChild(p);

        const s = document.createElement(tagS);
        // Create non-configurable own property
        Object.defineProperty(s, 'foo', {
          value: 'skipped-initial',
          configurable: false,
          writable: true,
          enumerable: true,
        });
        document.getElementById('skipped-host').appendChild(s);

        // Define both components (will upgrade existing nodes)
        defineComponent(tagP, {
          initialProps: { foo: '' },
          template: `<div>\${foo}</div>`,
        });

        defineComponent(tagS, {
          initialProps: { foo: '' },
          template: `<div>\${foo}</div>`,
        });

        // Helpers
        const getContent = (el) => (el.shadowRoot ?? el).textContent.trim();

        const updateDisplays = () => {
          document.getElementById('p-render').textContent = getContent(p);
          document.getElementById('s-render').textContent = getContent(s);
        };

        // Buttons
        document
          .getElementById('p-host-update')
          .addEventListener('click', () => {
            p.foo = 'HOST-UPDATED';
            updateDisplays();
          });
        document
          .getElementById('p-attr-update')
          .addEventListener('click', () => {
            p.setAttribute('foo', 'ATTR-UPDATED');
            updateDisplays();
          });

        document
          .getElementById('s-host-update')
          .addEventListener('click', () => {
            // This writes to the host property, but for the non-configurable case
            // the proxy was skipped so internal component won't see it.
            s.foo = 'HOST-UPDATED';
            updateDisplays();
          });
        document
          .getElementById('s-attr-update')
          .addEventListener('click', () => {
            // Setting attribute triggers attributeChangedCallback which will
            // update the internal component regardless of proxying.
            s.setAttribute('foo', 'ATTR-UPDATED');
            updateDisplays();
          });

        // Initial render
        setTimeout(updateDisplays, 50);
      })();
    </script>
  </body>
</html>
