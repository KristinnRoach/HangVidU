import { db } from '../firebase.js';

import {
  setConnectionStatus,
  listenForPartnerReconnection,
  clearConnectionStatus,
} from '../connectionStatus.js';

let reconnectionListener = null;

export function setupReconnectionListener(roomId, role) {
  reconnectionListener = listenForPartnerReconnection(
    roomId,
    role,
    handlePartnerReconnecting
  );
}

export async function handlePartnerReconnecting(isInitiator) {
  updateStatus('Partner reconnecting...');

  // Remove old Firebase listeners
  cleanupFirebaseListeners();

  // Close existing peer connection
  if (peerConnection) {
    peerConnection.close();
    peerConnection = null;
  }

  // Clear remote video
  if (remoteVideo.srcObject) {
    remoteVideo.srcObject = null;
  }

  if (isInitiator) {
    // Initiator creates new offer
    await createNewOffer();
  } else {
    // Joiner waits for new offer - set up persistent listener
    updateStatus('Waiting for partner to reconnect...');
    const roomRef = db.ref(`rooms/${roomId}`);

    roomRef.child('offer').on('value', async (snapshot) => {
      await handleOfferSnapshot(snapshot);
      // Remove the listener after processing the offer
      roomRef.child('offer').off('value');
    });

    // Immediately check if an offer already exists
    const existingOfferSnapshot = await roomRef.child('offer').once('value');
    if (existingOfferSnapshot.val()) {
      await handleOfferSnapshot(existingOfferSnapshot);
    }
  }
}

export async function handleOfferSnapshot(snapshot) {
  const offer = snapshot.val();
  console.log('[RECONN-DEBUG] Joiner received offer snapshot:', offer);
  if (!offer) return;

  // Create fresh peer connection
  peerConnection = new RTCPeerConnection(configuration);

  localStream.getTracks().forEach((track) => {
    peerConnection.addTrack(track, localStream);
  });

  console.log(
    '[DEBUG] Assigning peerConnection.ontrack in handleOfferSnapshot'
  );
  peerConnection.ontrack = setupRemoteStream;

  peerConnection.onicecandidate = (event) => {
    if (event.candidate) {
      db.ref(`rooms/${roomId}/callerCandidates`).push(event.candidate.toJSON());
    }
  };

  await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
  const answer = await peerConnection.createAnswer();
  await peerConnection.setLocalDescription(answer);
  console.log('[RECONN-DEBUG] Joiner setting answer in Firebase:', {
    type: answer.type,
    sdp: answer.sdp,
  });
  await db
    .ref(`rooms/${roomId}/answer`)
    .set({ type: answer.type, sdp: answer.sdp });
  console.log('[RECONN-DEBUG] Joiner set answer in Firebase.');

  // Listen for caller ICE candidates
  db.ref(`rooms/${roomId}/callerCandidates`).on('child_added', (snapshot) => {
    const candidate = snapshot.val();
    peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
  });

  await setConnectionStatus(roomId, 'joiner', 'connected');
}

export async function handleReconnection() {
  console.log(
    'ðŸ”„ handleReconnection started, isInitiator:',
    isInitiator,
    'roomId:',
    roomId
  );

  if (!roomId) {
    console.error('No roomId found for reconnection');
    updateStatus('Error: No room ID found for reconnection.');
    return;
  }
  const role = isInitiator ? 'initiator' : 'joiner';

  updateStatus('Reconnecting...');

  // Signal to partner that we're reconnecting
  await setConnectionStatus(roomId, role, 'reconnecting');

  // Small delay to let partner detect and reset
  await new Promise((resolve) => setTimeout(resolve, 1000));

  // Clear stale offer/answer
  const roomRef = db.ref(`rooms/${roomId}`);
  if (isInitiator) {
    await roomRef.child('answer').remove();
    await roomRef.child('calleeCandidates').remove();
  } else {
    await roomRef.child('callerCandidates').remove();
    await roomRef.child('offer').remove();
  }

  // Follow role-based reconnection
  if (isInitiator) {
    await createNewOffer();
  }
  // Joiner waits - partner will trigger new offer via handlePartnerReconnecting
}

export async function createNewOffer() {
  // Create fresh peer connection
  peerConnection = new RTCPeerConnection(configuration);

  localStream.getTracks().forEach((track) => {
    peerConnection.addTrack(track, localStream);
  });

  console.log('[DEBUG] Assigning peerConnection.ontrack in createNewOffer');
  peerConnection.ontrack = setupRemoteStream;

  const roomRef = db.ref(`rooms/${roomId}`);

  peerConnection.onicecandidate = (event) => {
    if (event.candidate) {
      roomRef.child('callerCandidates').push(event.candidate.toJSON());
    }
  };

  // Create and send new offer
  const offer = await peerConnection.createOffer();
  await peerConnection.setLocalDescription(offer);
  await roomRef.child('offer').set(offer);

  // Listen for answer
  console.log(
    '[RECONN-DEBUG] Initiator attaching answer listener at path:',
    roomRef.child('answer').toString()
  );
  roomRef.child('answer').on('value', async (snapshot) => {
    const answer = snapshot.val();
    console.log('[RECONN-DEBUG] Initiator received answer snapshot:', answer);
    if (answer && !peerConnection.currentRemoteDescription) {
      await peerConnection.setRemoteDescription(
        new RTCSessionDescription(answer)
      );
      console.log(
        '[RECONN-DEBUG] Initiator set remote description with answer.'
      );
    }
  });
  // Immediately read back the answer from Firebase after attaching listener
  const answerSnapshot = await roomRef.child('answer').once('value');
  console.log(
    '[RECONN-DEBUG] Initiator immediate read-back answer from Firebase:',
    answerSnapshot.val()
  );

  // --- DEBUG: Delay before immediate read-back (remove if not needed) ---
  setTimeout(async () => {
    const delayedAnswerSnapshot = await roomRef.child('answer').once('value');
    console.log(
      '[RECONN-DEBUG] Initiator delayed (2s) read-back answer from Firebase:',
      delayedAnswerSnapshot.val()
    );
  }, 2000);

  // Listen for callee ICE candidates
  roomRef.child('calleeCandidates').on('child_added', (snapshot) => {
    const candidate = snapshot.val();
    peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
  });

  // Mark as connected
  await setConnectionStatus(roomId, 'initiator', 'connected');

  // Set up reconnection listener
  reconnectionListener = listenForPartnerReconnection(
    roomId,
    'initiator',
    handlePartnerReconnecting
  );

  updateStatus('Reconnected! Waiting for partner...');
}
