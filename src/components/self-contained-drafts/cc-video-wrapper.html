<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Video Component (Factory)</title>
    <style>
      body {
        margin: 0;
        font-family: sans-serif;
        background-color: #f0f0f0;
        overflow: hidden; /* Prevent body scroll when fixed elements are present */
      }

      .video-wrapper {
        display: block;
        position: relative;
        transition: all 0.5s ease-in-out;
        background-color: black; /* To make sure we see the container */
        border: 2px solid grey; /* To make sure we see the container */
      }

      .video-wrapper video {
        width: 100%;
        height: 100%;
        display: block;
        object-fit: contain;
      }

      .video-wrapper .toggle-button {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        border: none;
        padding: 8px 12px;
        border-radius: 4px;
        cursor: pointer;
        z-index: 10;
      }

      /* Layout A: Full viewport */
      .video-wrapper.fullscreen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 999;
      }

      .video-wrapper input,
      .video-wrapper button:not(.toggle-button) {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        border: none;
        padding: 8px 12px;
        border-radius: 4px;
        z-index: 10;
      }

      .video-wrapper input {
        width: 200px;
      }
    </style>
  </head>
  <body>
    <script type="module">
      // dom-utils.js
      export const isDOMReady = () => document.readyState !== 'loading';
      export function onDOMReady(callback) {
        if (document.readyState !== 'loading') {
          callback();
        } else {
          document.addEventListener('DOMContentLoaded', callback);
        }
      }

      // src/utils/dev/dev-utils.js (mocked for this example)
      export const tempWarn = (...args) => console.warn(...args);

      // src/utils/dom/component-utils.js
      const sanitize = (str) => {
        const s = String(str);
        return s.replace(/[&<>"'`=\/]/g, (char) => {
          return {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;',
            '`': '&#x60;',
            '=': '&#x3D;',
            '/': '&#x2F;',
          }[char];
        });
      };

      const interpolate = (templateStr, props) => {
        return templateStr.replace(/\$\{([^}]+)\}/g, (_, key) => {
          const trimmedKey = key.trim();
          const value = trimmedKey
            .split('.')
            .reduce((obj, prop) => obj?.[prop], props);
          if (value == null) return '';
          const isHtml = trimmedKey.endsWith('Html');
          return isHtml ? String(value) : sanitize(String(value));
        });
      };

      const createDOMFragment = (templateStr, props = {}) => {
        const template = document.createElement('template');
        template.innerHTML = interpolate(templateStr, props);
        return template.content.cloneNode(true);
      };

      const getPathForElement = (root, target) => {
        const path = [];
        let node = target;
        while (node && node !== root) {
          const parent = node.parentElement;
          if (!parent) break;
          const idx = Array.prototype.indexOf.call(parent.children, node);
          path.push(idx);
          node = parent;
        }
        return path.reverse();
      };

      const getElementByPath = (root, path) => {
        return path.reduce(
          (node, idx) => (node && node.children ? node.children[idx] : null),
          root
        );
      };

      const captureInputState = (element) => {
        return Array.from(
          element.querySelectorAll('input, textarea, select')
        ).map((el) => ({
          name: el.name,
          id: el.id,
          path: getPathForElement(element, el),
          value: el.value,
          checked: el.checked,
          selectionStart: el.selectionStart,
          selectionEnd: el.selectionEnd,
          wasFocused: document.activeElement === el,
        }));
      };

      const escapeCSSSelector = (str) => str.replace(/["'\\]/g, '\\$&');

      const restoreInputState = (element, states) => {
        states.forEach((state) => {
          let el = null;
          if (state.name) {
            const safeName = escapeCSSSelector(state.name);
            el = element.querySelector(
              `input[name="${safeName}"], textarea[name="${safeName}"], select[name="${safeName}"]`
            );
          } else if (state.id) {
            el = element.querySelector(`#${state.id}`);
          } else if (state.path) {
            el = getElementByPath(element, state.path);
          }

          if (el) {
            el.value = state.value;
            if (state.checked !== undefined) el.checked = state.checked;
            if (state.selectionStart != null && el.setSelectionRange) {
              try {
                el.setSelectionRange(state.selectionStart, state.selectionEnd);
              } catch {}
            }
            if (state.wasFocused) {
              try {
                el.focus();
              } catch {}
            }
          }
        });
      };

      const captureMediaState = (element) => {
        return Array.from(element.querySelectorAll('video, audio')).map(
          (el) => ({
            src: el.currentSrc || el.src,
            currentTime: el.currentTime,
            paused: el.paused,
            volume: el.volume,
            playbackRate: el.playbackRate,
            muted: el.muted,
          })
        );
      };

      const findMediaBySrc = (root, targetSrc) => {
        const list = root.querySelectorAll('video, audio');
        for (const node of list) {
          if (node.currentSrc === targetSrc || node.src === targetSrc)
            return node;
        }
        return null;
      };

      const restoreMediaState = (element, states) => {
        states.forEach((state) => {
          if (!state.src) return;
          const el = findMediaBySrc(element, state.src);
          if (el) {
            el.currentTime = state.currentTime;
            el.volume = state.volume;
            el.playbackRate = state.playbackRate;
            el.muted = state.muted;
            if (!state.paused) {
              el.play().catch(() => {});
            }
          }
        });
      };

      const html = createDOMFragment;

      // src/utils/dom/component.js (your provided factory function)
      const createComponent = ({
        initialProps,
        template,
        handlers = {},
        parent = null,
        containerTag = 'div',
        className = '',
        onMount = null,
        onCleanup = null,
        autoAppend = true,
        preserveInputState = true,
      }) => {
        if (!isDOMReady()) {
          console.error(
            'createComponent: DOM must be ready before creating components.'
          );
          return null;
        }

        const element = document.createElement(containerTag); // container tag customizable
        if (className) element.className = className;

        let currentProps = { ...initialProps };

        // Track which props are actually used in the template
        const usedProps = new Set();
        const placeholderRegex = /\$\{([^}]+)\}/g;
        let match;
        while ((match = placeholderRegex.exec(template)) !== null) {
          const key = match[1].trim().split('.')[0]; // Get root prop (e.g., "user" from "user.name")
          usedProps.add(key);
        }

        // Global update listeners (any prop updated)
        const renderListeners = []; // onRender listeners (after render)
        const anyUpdateListeners = []; // onAnyPropUpdated listeners (after state change, render optional)

        // Per-prop listeners map: { propName: [callback, ...] }
        const singlePropListeners = {};

        const render = () => {
          // Capture state before render if needed
          let inputState = [];
          let mediaState = [];
          if (preserveInputState) {
            inputState = captureInputState(element);
            mediaState = captureMediaState(element);
          }

          // Render
          element.textContent = '';
          const content = html(template, currentProps);
          element.appendChild(content);

          // Attach event handlers // TODO: optimize to avoid re-adding on every render
          Object.keys(handlers).forEach((handlerName) => {
            const elements = element.querySelectorAll(
              `[data-onclick="${handlerName}"]`
            ); // Changed from 'onclick' to 'data-onclick'
            const fn = handlers[handlerName];
            elements.forEach((el) => {
              // el.removeAttribute('onclick'); // No need to remove 'onclick' if using data-onclick
              if (typeof fn === 'function') {
                el.addEventListener('click', fn);
              }
            });
          });

          // Restore state after render
          if (preserveInputState) {
            restoreInputState(element, inputState);
            restoreMediaState(element, mediaState);
          }

          // Notify listeners // TODO: optimize
          renderListeners.forEach((listener) => listener({ ...currentProps }));
        };

        const notifyPropsUpdated = (changedKeys) => {
          if (!Array.isArray(changedKeys) || changedKeys.length === 0) return;
          const payload = { props: { ...currentProps }, changedKeys };
          anyUpdateListeners.forEach((listener) => listener(payload));
        };

        // Define getters/setters with per-prop event notification
        for (const prop of Object.keys(initialProps)) {
          singlePropListeners[prop] = [];

          Object.defineProperty(element, prop, {
            get() {
              return currentProps[prop];
            },
            set(value) {
              if (currentProps[prop] !== value) {
                currentProps[prop] = value;
                // Only re-render if this prop is actually used in the template
                if (usedProps.has(prop)) {
                  render();
                }
                // Always notify per-prop listeners
                singlePropListeners[prop].forEach((cb) => cb(value));
                // Notify global props-updated listeners for single prop change
                notifyPropsUpdated([prop]);
              }
            },
            configurable: true,
            enumerable: true,
          });
        }

        element.update = (newProps) => {
          let changed = false;
          let shouldRender = false;
          const changedKeys = [];

          for (const key in newProps) {
            if (newProps[key] !== currentProps[key]) {
              currentProps[key] = newProps[key];
              // Check if this prop is used in template
              if (usedProps.has(key)) {
                shouldRender = true;
              }
              // Notify per-prop listeners on batch update
              if (singlePropListeners[key]) {
                singlePropListeners[key].forEach((cb) => cb(newProps[key]));
              }
              changed = true;
              changedKeys.push(key);
            }
          }

          // Only re-render if a prop used in the template changed
          if (changed && shouldRender) {
            render(); // render() already calls updateListeners
          }

          // Notify global props-updated listeners once per batch
          if (changedKeys.length > 0) {
            notifyPropsUpdated(changedKeys);
          }
        };

        /**
         * Registers a callback to run on any prop update.
         * @param {function} listener - Callback receiving current props object.
         */
        element.onRender = (listener) => {
          if (typeof listener === 'function') {
            renderListeners.push(listener);
          }
        };

        /**
         * Registers a callback to run when one or more props are updated (via setter or update()).
         * Called even if no re-render occurs. Listener receives { props, changedKeys }.
         * @param {function} listener
         */
        element.onAnyPropUpdated = (listener) => {
          if (typeof listener === 'function') {
            anyUpdateListeners.push(listener);
          }
        };

        /**
         * Registers a callback to run when a specific prop changes.
         * @param {string} prop - Property name to listen for.
         * @param {function} listener - Callback receiving the new prop value.
         */
        element.onPropUpdated = (prop, listener) => {
          if (typeof listener === 'function' && singlePropListeners[prop]) {
            singlePropListeners[prop].push(listener);
          }
        };

        /**
         * Cleanup method to remove all listeners and detach from parent.
         * Call this when component is no longer needed to prevent memory leaks.
         */
        element.dispose = () => {
          // Run custom cleanup functions if provided
          if (onCleanup) {
            if (Array.isArray(onCleanup)) {
              onCleanup.forEach((fn) => {
                if (typeof fn === 'function') fn();
              });
            } else if (typeof onCleanup === 'function') {
              onCleanup();
            }
          }

          renderListeners.length = 0;
          anyUpdateListeners.length = 0;
          for (const prop in singlePropListeners) {
            singlePropListeners[prop].length = 0;
          }
          element.remove();
        };

        render();

        if (autoAppend && parent && !parent.contains(element)) {
          parent.appendChild(element);
        }

        // Call onMount after initial render and (if enabled) append
        if (typeof onMount === 'function') {
          try {
            onMount(element);
          } catch (e) {
            tempWarn(
              '[createComponent]: Error in onMount handler of component',
              e
            );
            /* no-op */
          }
        }

        return element;
      };

      // --- Component Implementation ---
      onDOMReady(() => {
        const videoComponent = createComponent({
          initialProps: {
            isFullScreen: false,
            buttonText: 'Fullscreen',
            className: 'video-wrapper', // Apply base class
            url: 'https://www.w3schools.com/html/mov_bbb.mp4',
          },
          template: `
            <button class="toggle-button" data-onclick="toggleLayout">\${buttonText}</button>
            <video
              src="\${url}"
              controls
              autoplay
              loop
              muted
            ></video>
            <input type="text" id="urlInput">
            <button data-onclick="updateUrl">Update URL</button>
          `,
          handlers: {
            toggleLayout: function () {
              videoComponent.isFullScreen = !videoComponent.isFullScreen;
            },
            updateUrl: function () {
              const input = this.querySelector('#urlInput');
              videoComponent.url = input.value;
            },
          },
          parent: document.body,
        });

        // React to isFullScreen prop changes to update class and button text
        videoComponent.onPropUpdated('isFullScreen', (newValue) => {
          if (newValue) {
            videoComponent.classList.add('fullscreen');
            videoComponent.buttonText = 'Exit Fullscreen';
          } else {
            videoComponent.classList.remove('fullscreen');
            videoComponent.buttonText = 'Fullscreen';
          }
        });

        // Initialize class based on initialProps
        if (videoComponent.isFullScreen) {
          videoComponent.classList.add('fullscreen');
        }
      });
    </script>
  </body>
</html>
